<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script>
# 个人心得

* 姓名：陈宏霖


* 学号：3150101233

* 邮箱：chl9797@live.com

  ​	本项目中，我担任组长，主要负责ViewModel、Model层框架的搭建和Model层部分数学计算函数的实现和与解释器的绑定。

  ## 主要工作

  ### MVVM框架设计（Common&Model&ViewModel部分）

  ##### Common层

  >​	Common层，我们设计了iCommand类作为Model层中Command的基类；设计了INotification和Proxy_Notification两个类分别作为被观察者和观察者的基类，其中INotification类由View层和ViewModel层继承，Proxy_Notification类由ViewModel层和Model层继承；设计了参数的基类并派生出StringParam类来在ViewModel层的Command中传递输入的字符串参数。
  >
  >​

  ##### Model层

  >​	在Model层，Model类继承了Proxy_Notification类，含有2个共享指针shared_ptr来暴露出内部的表示输出结果的字符串参数和表示一系列用来作图的点的集合的参数。每当内部参数发生改变时，就使用notify函数通知ViewModel层自身的变化。此外，为了实现redo和undo，我们设计了一个vector数组DoneList来记录每一步改变的参数类型和参数值，并记录下当前动作在数组中的位置pos，每次redo和undo动作可以改变当前位置pos，从而改变共享指针暴露出的参数。
  >
  >> ![Model设计.jpg](https://github.com/Lppy/Calculation/blob/master/doc/%E8%AE%BE%E8%AE%A1%E5%9B%BE/Model%E8%AE%BE%E8%AE%A1.jpg?raw=true)

  ##### ViewModel层

  >​	在ViewModel层，ViewModel类继承了Proxy_Notification、INotification两个类，同时作为Model层的被观察者和View层的观察者。在Command层我们从iCommand类派生出CalculateCommand, RedoCommand和UndoCommand类，并通过共享指针和View层绑定，实现科学计算、重做、后退等功能。ViewModel层含有1个共享指针用来绑定Model，和2个共享指针分别用来指向表示输出结果的字符串和一系列用来作图的点，而输入的字符串则直接作为参数传递。
  >
  >![ViewModel设计.jpg](https://github.com/Lppy/Calculation/blob/master/doc/%E8%AE%BE%E8%AE%A1%E5%9B%BE/ViewModel%E8%AE%BE%E8%AE%A1.jpg?raw=true)

  ### Model层功能设计

>Model层功能主要分为2个部分：
>
>##### 一、部分数学计算功能：
>
>1. 矩阵求条件数：可选求2的条件数和无穷的条件数
>
>$$ cond(A)=||A||*||A^{-1} || $$
>
>$$||A||_2=\sqrt{\lambda_{max}(A^TA)}$$
>
>$$||A||_\infty=\max_{1\le i\le n}\sum_{j=1}^{n}|a_{ij}|$$
>
>(1) 求$A^{-1}$:由$AA^{-1}=E$, 将$A^{-1}$按列分为n个向量，通过LU分解的方法求解出$A^{-1}$的每个列向量，最后合并得到$A^{-1}$。
>
>(2) 求2的范数：先计算$A^TA$，再通过反幂法逼近$A^TA$的最大特征值，开根号后求出2的范数。
>
>(3) 求无穷的范数：求出$A$中和最大的一行，这个和即为无穷范数。
>
>(4) 求条件数：$A$和$A^{-1}$的相应范数相乘，即为相应的条件数。
>
>2. 求解高阶方程
>
>   将函数的定义域分段，对每段使用牛顿法迭代求解，通过缩小子区间长度来加速收敛，精度设置为0.01，并使用如下公式避免重根：
>
>   $$g(x)=x- \frac {f(x)f'(x)}{[f'(x)]^2-f(x)f''(x)}$$
>
>3. 求解定积分
>
>   使用Romberg积分法求解定积分$\int_a^b{f(x)}$。
>
>   $$h_k=(b-a)/2^{k-1}$$
>
>   $$R_{k,1}=\frac{1}{2}[R_{k-1,1}+h_{k-1}\sum_{i=1}^{2^{k-2}}f(a+(2i-1)h_k)]$$
>
>   $$R_{k,j}=R_{k,j-1}+\frac{R_{k,j-1}-R_{k-1,j-1}}{4^{j-1}-1}$$
>
>   迭代至$|R_{n-1,n-1}-R_{n,n}|$和$|R_{n-2,n-2}-R_{n-1,n-1}|$同时在误差范围内以避免偶然情况。
>
>4. 求解常微分方程
>
>   使用4阶Runge-Kutta法求解。
>
>   $$\omega_0=\alpha$$
>
>      $$k_1=hf(t_i,\omega_i)$$
>
>   $$k_2=hf(t_i+\frac{h}{2},\omega_i+\frac12k_1)$$
>
>   $$k_3=hf(t_i+\frac h2,\omega_i+\frac12k_2)$$
>
>   $$k_4=hf(t_{i+1},\omega_i+k_3)$$
>
>   $$\omega_{i+1}=\omega_i+\frac16(k_I+2k_2+2k_3+k_4)$$
>   $$
>   k_1=hf(t_i,\omega_i)
>   $$
>
>5. 样条曲线拟合
>
>   使用自然样条曲线拟合出比点数高一阶的多项式$S(x)$。
>
>   $$S(x_j)=f(x_j)$$
>
>   $$S_{j+1}(x_{j+1})=S_j(x_{j+1})$$
>
>   $$S_{j+1}'(x_{j+1})=S_j'(x_{j+1})$$
>
>   $$S_{j+1}''(x_{j+1})=S_j''(x_{j+1})$$
>
>   $$S''(x_0)=S''(x_n)=0$$

>##### 二、Model层与解释器的绑定：
>
>​	用类似iCommand绑定的方法，由一个基类iBinding派生出PolyBinding,MatrixBinding,CurveBinding等派生类，将解释器和Model层的数学功能一一绑定，在Model层通过一个map\<string,iBinding>由输入的指令格式找到相应的Binding类并执行。



 		在本项目的组织和开发过程中，我在以下方面有了更加深刻的认识：

## mvvm框架

>这是我第一次接触到框架这一概念，在mvvm框架的实现中，我提高了自身对框架的理解，也充分感受到了mvvm框架减少耦合对团队工作效率的提高。

## 团队协作

>这是我第一次担任团队中的组长，也提高了个人对团队协作的理解。我感受最深的是团队沟通的重要性，在Model层实现时将解释器和内部功能绑定的过程中，我和另一位队友因为沟通的不及时，重复完成了同一个功能，因而团队的有效沟通在团队协作中是十分重要的。

​	最后，经过十多天的共同努力和版本迭代，我们成功实现了我们的miniMatlab， 也要感谢老师对我们的耐心指导和大家的齐心协力。
